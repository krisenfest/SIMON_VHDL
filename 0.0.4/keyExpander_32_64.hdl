library IEEE;
use IEEE.std_logic_1164.all;
use std.textio.all; 
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.printerlib.all;

entity keyExpander_32_64 is
    port(
        Z: in std_logic_vector(61 downto 0);
        keyIn: in std_logic_vector(255 downto 0);
        keyOut: out std_logic_vector(255 downto 0);
        returnZ: out std_logic_vector(61 downto 0)
    );
end keyExpander_32_64;

architecture behaviour of keyExpander_32_64 is 
-- //////// //////// //////// //////// //////// //////// //////// ////////
    -- key expansion function
    function morph_Z(Z: std_logic_vector)
    return std_logic_vector is
        variable Z_manipulator: std_logic_vector(61 downto 0) := Z;
    begin
        return Z_manipulator(Z_manipulator'length-2 downto 0) & Z_manipulator(Z_manipulator'length-1);
    end function;

    function getNextKey_32_64(keyIn, Z: std_logic_vector)
    return std_logic_vector is
        variable key_0: std_logic_vector(15 downto 0) := keyIn(63 downto 48);
        variable key_1: std_logic_vector(15 downto 0) := keyIn(47 downto 32);
        variable key_2: std_logic_vector(15 downto 0) := keyIn(31 downto 16);
        variable key_3: std_logic_vector(15 downto 0) := keyIn(15 downto 0);
        variable combiner: std_logic_vector(63 downto 0) := (others => '0');
        variable temp: std_logic_vector(15 downto 0);
        variable returnValue: std_logic_vector(255 downto 0) := (others => '0');
        variable Z_manipulator: std_logic_vector(61 downto 0) := Z;
    begin

        temp := key_0(2 downto 0) & key_0(key_0'length-1 downto 3);
        temp := temp xor key_2;
        temp := temp xor (temp(0) & temp(temp'length-1 downto 1));
        temp := temp xor key_3;
        temp := temp xor ("000000000000000" & Z_manipulator(Z_manipulator'length-1));
            Z_manipulator := morph_Z(Z_manipulator);
        temp := temp xor "1111111111111100";


        combiner := temp & key_0 & key_1 & key_2 ;
        return (returnValue'length-1 downto combiner'length => '0') & combiner;
    end function;

begin
    process(keyIn, Z)
    begin
        keyOut <= getNextKey_32_64(keyIn,Z);
        returnZ <= morph_Z(Z);
    end process;

end behaviour;